/**
 * AI Commit Message Generator - VSCode Extension
 * Main entry point
 */
import * as vscode from 'vscode';
import { callWithFallback } from './providers';
import { getStagedDiff, getStagedFiles, getUnstagedDiff, getUnstagedFiles, detectTechStack, getDiffStats } from './services/git';
import { buildSystemPrompt, buildUserPrompt } from './services/prompt';
import { hasAnyProvider } from './config';

/**
 * Extension activation
 */
export function activate(context: vscode.ExtensionContext) {
  console.log('AI Commit Generator is now active!');
  
  // Register the main command
  const generateCommand = vscode.commands.registerCommand(
    'aiCommit.generate',
    generateCommitMessage
  );
  
  context.subscriptions.push(generateCommand);
}

/**
 * Main command handler - Generate commit message
 */
async function generateCommitMessage() {
  // Check if any provider is configured
  if (!hasAnyProvider()) {
    const action = await vscode.window.showErrorMessage(
      'No AI provider configured. Please set at least one API key in settings.',
      'Open Settings'
    );
    
    if (action === 'Open Settings') {
      vscode.commands.executeCommand('workbench.action.openSettings', 'aiCommit');
    }
    return;
  }
  
  // Show progress
  await vscode.window.withProgress(
    {
      location: vscode.ProgressLocation.Notification,
      title: 'AI Commit Generator',
      cancellable: true
    },
    async (progress, token) => {
      try {
        // Step 1: Get staged changes
        progress.report({ message: 'Reading changes...' });
        
        let [diff, files] = await Promise.all([
          getStagedDiff(),
          getStagedFiles()
        ]);
        
        let usingUnstaged = false;
        
        if (!diff || files.length === 0) {
          // Try unstaged changes
          [diff, files] = await Promise.all([
            getUnstagedDiff(),
            getUnstagedFiles()
          ]);
          
          if (diff && files.length > 0) {
            usingUnstaged = true;
          } else {
            vscode.window.showWarningMessage(
              'No changes found (staged or unstaged) to generate a commit message.'
            );
            return;
          }
        }
        
        if (token.isCancellationRequested) {
          return;
        }
        
        // Step 2: Analyze context
        progress.report({ message: 'Analyzing changes...' });
        
        const techStack = detectTechStack(files);
        const stats = getDiffStats(diff);
        
        // Step 3: Build prompts
        const systemPrompt = buildSystemPrompt();
        const userPrompt = buildUserPrompt(diff, files, techStack, stats);
        
        if (token.isCancellationRequested) {
          return;
        }
        
        // Step 4: Call AI with fallback
        progress.report({ message: 'Generating commit message...' });
        
        const { response, provider } = await callWithFallback(
          systemPrompt,
          userPrompt,
          (msg) => progress.report({ message: msg })
        );
        
        if (token.isCancellationRequested) {
          return;
        }
        
        // Step 5: Clean up the response
        let commitMessage = response.trim();
        
        // Remove markdown code blocks if present
        if (commitMessage.startsWith('```')) {
          commitMessage = commitMessage
            .replace(/^```[\w]*\n?/, '')
            .replace(/\n?```$/, '')
            .trim();
        }
        
        // Step 6: Direct Fill or Copy
        const gitExtension = vscode.extensions.getExtension('vscode.git');
        
        if (gitExtension) {
          const git = gitExtension.exports.getAPI(1);
          if (git.repositories.length > 0) {
            // Select the first repository (or finding the one matching current workspace would be better)
            const repo = git.repositories[0];
            repo.inputBox.value = commitMessage;
            
            vscode.window.showInformationMessage(
              `Commit message generated by ${provider.name}${usingUnstaged ? ' (from UNSTAGED)' : ''}`
            );
          } else {
             await vscode.env.clipboard.writeText(commitMessage);
             vscode.window.showInformationMessage('No active repository found. Copied to clipboard instead.');
          }
        } else {
          await vscode.env.clipboard.writeText(commitMessage);
          vscode.window.showInformationMessage('Git extension not found. Copied to clipboard.');
        }
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        
        if (errorMessage.includes('No workspace')) {
          vscode.window.showErrorMessage('Please open a folder with a git repository first.');
        } else if (errorMessage.includes('not a git repository')) {
          vscode.window.showErrorMessage('This folder is not a git repository.');
        } else {
          vscode.window.showErrorMessage(`Failed to generate commit message: ${errorMessage}`);
        }
      }
    }
  );
}

/**
 * Extension deactivation
 */
export function deactivate() {
  console.log('AI Commit Generator deactivated');
}
